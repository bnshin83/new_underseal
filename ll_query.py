## This is used in result upload script

import pyodbc
import cx_Oracle
import db
import excel
import os, re

#ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
def check_f25_filename(f25_str):
    """
    Need to write test case for this one
    """
    pattern = r'^RP-\d+\+-?\d+\.?\d? to RP-\d+\+-?\d+\.?\d?'
    if not re.match(pattern,f25_str):
        raise Exception('F25 filename does not meet requirement')
    
def find_ll_no_given_req_no(con, filename, req_no):
    ll_no = None
    sqlstr = """
                    SELECT longlist_no FROM stda_longlist_info
                    WHERE request_no='""" + str(req_no) + """'
                    """
    cursor = con.cursor()
    cursor.execute(sqlstr)
    for result in cursor:
        ll_no = str(result[0])
    cursor.close()
    if ll_no is None:
        raise Exception('For {} Cannot find corresponding LongList Number given the Request Number {}'.format(filename,req_no))
    return ll_no

def find_req_no_given_ll_no(con, filename, ll_no, year):
    req_no = None
    cursor = con.cursor()
    cursor.execute("""
                   SELECT request_no
                   FROM stda_longlist_info
                   WHERE year= :year AND longlist_no = :longlist_no
                   """, [str(year), ll_no])

    for result in cursor:
        req_no = result[0]
    cursor.close()
    if ll_no is None:
        raise Exception('Cannot find corresponding Request Number for {} given the LL Number {} and Year {}'.format(filename,
                                                                                                                    ll_no,
                                                                                                                    year))


def compose_ll_entry_string(ll_no, f25_path, year, start_gps, end_gps, pavtype, args, user_input_dict):
    base_f25_path = os.path.basename(f25_path)
    # new logic to check direction and lane info
    # Check if the f25 name matches the pattern
    if not args.user_input:
        check_f25_filename(" ".join(base_f25_path.split(" ")[2:]))
        dir = base_f25_path.split(" ")[1]
        if dir not in ['NB','SB','WB','EB']:
            raise Exception('Check if direction is included in F25 name after the first space!')
        lane_info = " ".join(base_f25_path.split(" ")[5:])
        lane_info = lane_info[:-4] # Use [:-4] get rid of the extention name like '.F25'

        # Categorize lane_info into 10 classes
        if lane_info == '' or 'DL' in lane_info or 'OLD' in lane_info:
            lane_type = 'DL'
        elif 'LN1' in lane_info or 'LN 1' in lane_info:
            lane_type = 'LN1'
        elif 'LN2' in lane_info or 'LN 2' in lane_info:
            lane_type = 'LN2'
        elif 'LN3' in lane_info or 'LN 3' in lane_info:
            lane_type = 'LN3'
        elif 'LN4' in lane_info or 'LN 4' in lane_info:
            lane_type = 'LN4'
        elif 'LN5' in lane_info or 'LN 5' in lane_info:
            lane_type = 'LN5'
        elif 'PL' in lane_info:
            lane_type = 'PL'
        elif 'sh' in lane_info.lower():
            lane_type = 'SHOULDER'
        elif 'ramp' in lane_info.lower():
            lane_type = 'RAMP'
        else:
            # If it is special case, use whatever after 5th white space as lane_type
            if args.special_case:
                lane_type = lane_info
            else:
                lane_type = 'UNKNOWN'
    else:
        lane_type = user_input_dict['lane_type']
        dir = user_input_dict['dir']

    if start_gps and end_gps:
        if start_gps[0] and start_gps[1]:
            start_gps_x = str(start_gps[0])
            start_gps_y = str(start_gps[1])
        else:
            start_gps_x, start_gps_y = "NULL", "NULL"
        if end_gps[0] and end_gps[1]:
            end_gps_x = str(end_gps[0])
            end_gps_y = str(end_gps[1])
        else:
            end_gps_x, end_gps_y = "NULL", "NULL"
    else:
        start_gps_x, start_gps_y, end_gps_x, end_gps_y = "NULL", "NULL","NULL", "NULL"

    sqlstr = """INSERT INTO stda_LONGLIST
    VALUES (NULL,""" + ll_no + """, 
    '""" + str(year) + """', 
    '""" + dir + """',
    '""" + lane_type + """',
    '""" + pavtype + """',
    '""" + base_f25_path[:-4] + """', 
    '""" + base_f25_path[:-4]+'.docx' + """', 
    """ + start_gps_x + """, 
    """ + end_gps_x + """, 
    """ + start_gps_y + """, 
    """ + end_gps_y + """, 
    -1, NULL, -1, NULL)"""
    # print(sqlstr)

    idstr = """
    SELECT LONGLIST_ID FROM stda_LONGLIST
    WHERE LONGLIST_NO=""" + ll_no + """ AND 
    YEAR='""" + str(year) + """' AND 
    DIRECTION='""" + dir + """' AND
    PAVTYPE='""" + pavtype + """' AND
    F25_INFO='""" + base_f25_path[:-4] + """'
    """

    # print(idstr)
    return sqlstr, idstr, dir, lane_type

def ll_query(con, ll_no, f25_path, year, start_gps, end_gps, pavtype, args, user_input_dict, commit=0):

    cursor = con.cursor()
    sqlstr, idstr, dir, lane_type = compose_ll_entry_string(ll_no, f25_path, year, 
                                                            start_gps, end_gps, pavtype, args, user_input_dict)
    try:
        cursor.execute(sqlstr)
    except:
        raise Exception(sqlstr)
    cursor.execute(idstr)
    
    for result in cursor:
        print('Content of result: {}'.format(result))
        id = result[0]
    
    if commit:
        con.commit()
    cursor.close()
    return id, dir, lane_type


def get_ll_obj(con,ll_no,year):
    """
    retrive ll_obj from database, no longer relies on pkl files.
    ll_no: in the format of int
    year: in the format of string
    """
    retrived_ll_obj = {}
    retrived_ll_obj['llno'] = ll_no
    cursor = con.cursor()
    cursor.execute("""
                   SELECT test_status, request_no, route, rp_from, rp_to,
                          contract_no, district, traffic, name, date_req,
                          date_need, comments, operator_comment, traffic_ctrl, operator
                   FROM stda_longlist_info
                   WHERE year= :year AND longlist_no = :longlist_no
                   """, [str(year), ll_no])
    key_names = ["test status", "req no", "route", "rp from", "rp to",
                 "des no", "district", "traffic", "contact person", "date req",
                 "date needed", "comments", "operator_comment", "traffic_ctrl", "operator"]
    for results in cursor:
        for res,key in zip(results,key_names):
            retrived_ll_obj[key] = res
    
    return retrived_ll_obj

# Unit test of the functions
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description='Upload result in batch mode')
    parser.add_argument('--dev_env', type=str, default="shin",choices=['dev_wen', 'shin', 'ecn_wen','ecn_shin'])
    args = parser.parse_args()
    con = db.connect(args.dev_env)
    ll_obj = get_ll_obj(con,429,"2016")
    print(ll_obj)