## This is used in result upload script

import pyodbc
import cx_Oracle
import db
import excel
import os, re

from log_config import get_logger
logger = get_logger('ll_query')

#ID NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
def check_f25_filename(f25_str):
    """
    Need to write test case for this one
    """
    pattern = r'^RP-\d+\+-?\d+\.?\d? to RP-\d+\+-?\d+\.?\d?'
    if not re.match(pattern,f25_str):
        raise Exception('F25 filename does not meet requirement')
    
def find_ll_no_given_req_no(con, filename, req_no):
    ll_no = None
    cursor = con.cursor()
    cursor.execute("SELECT longlist_no FROM stda_longlist_info WHERE request_no = :1", [str(req_no)])
    for result in cursor:
        ll_no = str(result[0])
    cursor.close()
    if ll_no is None:
        raise Exception('For {} Cannot find corresponding LongList Number given the Request Number {}'.format(filename,req_no))
    return ll_no

def find_req_no_given_ll_no(con, filename, ll_no, year):
    req_no = None
    cursor = con.cursor()
    cursor.execute("""
                   SELECT request_no
                   FROM stda_longlist_info
                   WHERE year= :year AND longlist_no = :longlist_no
                   """, [str(year), ll_no])

    for result in cursor:
        req_no = result[0]
    cursor.close()
    if ll_no is None:
        raise Exception('Cannot find corresponding Request Number for {} given the LL Number {} and Year {}'.format(filename,
                                                                                                                    ll_no,
                                                                                                                    year))


def _parse_direction_and_lane(base_f25_path, args, user_input_dict):
    """Extract direction and lane_type from F25 filename or user input."""
    if not args.user_input:
        check_f25_filename(" ".join(base_f25_path.split(" ")[2:]))
        dir = base_f25_path.split(" ")[1]
        if dir not in ['NB','SB','WB','EB']:
            raise Exception('Check if direction is included in F25 name after the first space!')
        lane_info = " ".join(base_f25_path.split(" ")[5:])
        lane_info = lane_info[:-4] # Use [:-4] get rid of the extention name like '.F25'

        # Categorize lane_info into 10 classes
        if lane_info == '' or 'DL' in lane_info or 'OLD' in lane_info:
            lane_type = 'DL'
        elif 'LN1' in lane_info or 'LN 1' in lane_info:
            lane_type = 'LN1'
        elif 'LN2' in lane_info or 'LN 2' in lane_info:
            lane_type = 'LN2'
        elif 'LN3' in lane_info or 'LN 3' in lane_info:
            lane_type = 'LN3'
        elif 'LN4' in lane_info or 'LN 4' in lane_info:
            lane_type = 'LN4'
        elif 'LN5' in lane_info or 'LN 5' in lane_info:
            lane_type = 'LN5'
        elif 'PL' in lane_info:
            lane_type = 'PL'
        elif 'sh' in lane_info.lower():
            lane_type = 'SHOULDER'
        elif 'ramp' in lane_info.lower():
            lane_type = 'RAMP'
        else:
            if args.pavtype_special_case:
                lane_type = lane_info
            else:
                lane_type = 'UNKNOWN'
    else:
        lane_type = user_input_dict['lane_type']
        dir = user_input_dict['dir']
    return dir, lane_type

def ll_query(con, ll_no, f25_path, year, start_gps, end_gps, pavtype, args, user_input_dict, commit=0):

    base_f25_path = os.path.basename(f25_path)
    dir, lane_type = _parse_direction_and_lane(base_f25_path, args, user_input_dict)

    # Resolve GPS values (None for missing)
    start_gps_x = start_gps[0] if (start_gps and start_gps[0]) else None
    start_gps_y = start_gps[1] if (start_gps and start_gps[1]) else None
    end_gps_x = end_gps[0] if (end_gps and end_gps[0]) else None
    end_gps_y = end_gps[1] if (end_gps and end_gps[1]) else None

    f25_info = base_f25_path[:-4]

    cursor = con.cursor()
    cursor.execute("""INSERT INTO stda_LONGLIST
        VALUES (NULL, :ll_no, :year, :dir, :lane_type, :pavtype,
                :f25_info, :report_name,
                :start_lat, :end_lat, :start_lon, :end_lon,
                -1, NULL, -1, NULL)""",
        {'ll_no': int(ll_no), 'year': str(year), 'dir': dir,
         'lane_type': lane_type, 'pavtype': pavtype,
         'f25_info': f25_info, 'report_name': f25_info + '.docx',
         'start_lat': start_gps_x, 'end_lat': end_gps_x,
         'start_lon': start_gps_y, 'end_lon': end_gps_y})

    cursor.execute("""SELECT LONGLIST_ID FROM stda_LONGLIST
        WHERE LONGLIST_NO = :ll_no AND YEAR = :year AND DIRECTION = :dir
        AND PAVTYPE = :pavtype AND F25_INFO = :f25_info""",
        {'ll_no': int(ll_no), 'year': str(year), 'dir': dir,
         'pavtype': pavtype, 'f25_info': f25_info})

    longlist_id = None
    for result in cursor:
        logger.debug('Content of result: %s', result)
        longlist_id = result[0]

    if commit:
        con.commit()
    cursor.close()
    return longlist_id, dir, lane_type


def get_ll_obj(con,ll_no,year):
    """
    retrive ll_obj from database, no longer relies on pkl files.
    ll_no: in the format of int
    year: in the format of string
    """
    retrived_ll_obj = {}
    retrived_ll_obj['llno'] = ll_no
    cursor = con.cursor()
    cursor.execute("""
                   SELECT test_status, request_no, route, rp_from, rp_to,
                          contract_no, district, traffic, name, date_req,
                          date_need, comments, operator_comment, traffic_ctrl, operator
                   FROM stda_longlist_info
                   WHERE year= :year AND longlist_no = :longlist_no
                   """, [str(year), ll_no])
    key_names = ["test status", "req no", "route", "rp from", "rp to",
                 "des no", "district", "traffic", "contact person", "date req",
                 "date needed", "comments", "operator_comment", "traffic_ctrl", "operator"]
    for results in cursor:
        for res,key in zip(results,key_names):
            retrived_ll_obj[key] = res
    
    return retrived_ll_obj

# Unit test of the functions
if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description='Upload result in batch mode')
    parser.add_argument('--dev_env', type=str, default="shin",choices=['dev_wen', 'shin', 'ecn_wen','ecn_shin'])
    args = parser.parse_args()
    con = db.connect(args.dev_env)
    ll_obj = get_ll_obj(con,429,"2016")
    logger.info("ll_obj: %s", ll_obj)